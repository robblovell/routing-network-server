// Generated by CoffeeScript 1.10.0
(function() {
  var assert, async, driver, math, neo4j, should;

  should = require('should');

  assert = require('assert');

  math = require('mathjs');

  async = require('async');

  neo4j = require('neo4j-driver').v1;

  driver = neo4j.driver('bolt://sb10.stations.graphenedb.com:24786', neo4j.auth.basic('network', '3n6CUgoYeboY0PYjHLaa'));

  describe('Build Simple Graph', function() {
    var all, buildEdgesNInventory, buildGraph, buildResupplierRoutes, buildResuppliers, buildSKURelationships, buildSKUS, buildSellerSweepersNRoutes, buildSellers, buildWarehouses, buildZipRelationships, buildZips, costDistance, deleteGraph, edges, id, makeRoute, makeSkuRoute, nodes, persistGraph, routes, sellers, superdcs, sweep_sellers, warehouses;
    id = 1;
    routes = [];
    superdcs = [];
    warehouses = [];
    sweep_sellers = [];
    sellers = [];
    all = [];
    nodes = [];
    edges = [];
    deleteGraph = function(done) {
      var session, tx;
      session = driver.session();
      tx = session.beginTransaction();
      console.log("Delete edges");
      tx.run("MATCH ()-[r]->() DELETE r");
      console.log("Delete nodes");
      tx.run("MATCH (n) delete n");
      return tx.commit().subscribe({
        onCompleted: function() {
          console.log("delete completed");
          session.close();
          return done();
        },
        onError: function(error) {
          console.log(error);
          session.close();
          return done();
        }
      });
    };
    costDistance = function(node_location, decision, low, high) {
      var cost, decide, distance, location;
      decide = math.floor(math.random(-decision, decision));
      if (decide > 0) {
        distance = math.floor(math.random(low, high));
      } else {
        distance = math.floor(math.random(-low, -high));
      }
      location = math.floor(node_location + distance);
      if (location < 1) {
        location = node_location + 1;
      }
      if (location > 100) {
        location = node_location - 1;
      }
      distance = math.floor(math.abs(distance));
      cost = distance;
      return [location, cost, distance];
    };
    makeSkuRoute = function(id, source, kind, destination, inventory) {
      return {
        id: id,
        source: source,
        kind: 'sku',
        destination: destination,
        inventory: inventory
      };
    };
    buildResuppliers = function(callback) {
      var dallas, la, nj, resuppliers;
      nj = {
        id: 'nj',
        name: 'newjersey',
        location: 0,
        kind: 'superdc',
        inventory: 25,
        type: 'Superdc'
      };
      dallas = {
        id: 'dallas',
        name: 'dallas',
        location: 50,
        kind: 'superdc',
        inventory: 25,
        type: 'Superdc'
      };
      la = {
        id: 'losangeles',
        name: 'losangeles',
        location: 90,
        kind: 'superdc',
        inventory: 25,
        type: 'Superdc'
      };
      resuppliers = [nj, dallas, la];
      superdcs = [nj, dallas, la];
      warehouses = [dallas, la];
      all = [nj, dallas, la];
      return callback(null, {
        superdcs: resuppliers,
        resuppliers: resuppliers,
        warehouses: warehouses,
        all: all
      });
    };
    buildResupplierRoutes = function(args, callback) {
      var cost, distance, l, len, len1, m, resupplied, resupplier, route;
      routes = [];
      superdcs = args.resuppliers;
      for (l = 0, len = superdcs.length; l < len; l++) {
        resupplier = superdcs[l];
        for (m = 0, len1 = superdcs.length; m < len1; m++) {
          resupplied = superdcs[m];
          if (resupplier !== resupplied) {
            distance = math.abs(resupplier.location - resupplied.location);
            cost = distance;
            route = makeRoute(resupplier, resupplier, 'resupplies', resupplied, cost, distance);
            routes.push(route);
          }
        }
      }
      args.routes = routes;
      return callback(null, args);
    };
    buildWarehouses = function(args, callback) {
      var cost, distance, i, j, k, l, len, location, m, ref, ref1, resupplier, resupplier2, route, warehouse, warehousesPerSuperDC;
      j = 0;
      superdcs = args.superdcs;
      warehouses = args.warehouses;
      routes = args.routes;
      all = args.all;
      warehousesPerSuperDC = 3;
      for (k = l = 0, len = superdcs.length; l < len; k = ++l) {
        resupplier = superdcs[k];
        if (k < superdcs.length) {
          resupplier2 = superdcs[k + 1];
        } else {
          resupplier2 = superdcs[0];
        }
        for (i = m = 1, ref = warehousesPerSuperDC; 1 <= ref ? m <= ref : m >= ref; i = 1 <= ref ? ++m : --m) {
          ref1 = costDistance(resupplier.location, 1000, 3, 7), location = ref1[0], cost = ref1[1], distance = ref1[2];
          warehouse = {
            id: "ware" + j,
            name: "warehouse " + j,
            location: location,
            kind: 'warehouse',
            type: 'Warehouse'
          };
          warehouses.push(warehouse);
          all.push(warehouse);
          route = makeRoute(id++, resupplier, 'resupplies', warehouse, cost, distance);
          routes.push(route);
          j += 1;
          if ((resupplier2 != null)) {
            distance = math.floor(math.random(-12, 12));
            location = math.floor(resupplier2.location + distance);
            distance = math.floor(math.abs(distance));
            cost = distance;
            warehouse = {
              id: "ware" + j,
              name: "warehouse " + j,
              location: location,
              kind: 'warehouse',
              type: 'Warehouse'
            };
            warehouses.push(warehouse);
            all.push(warehouse);
            route = makeRoute(id++, resupplier2, 'resupplies', warehouse, cost, distance);
            routes.push(route);
            j += 1;
          }
        }
      }
      return callback(null, args);
    };
    buildSellerSweepersNRoutes = function(args, callback) {
      var cost, distance, i, j, k, l, len, location, m, ref, ref1, route, seller, sweepersPerWarehouse, warehouse;
      j = 100;
      warehouses = args.warehouses;
      all = args.all;
      routes = args.routes;
      sweep_sellers = [];
      sweepersPerWarehouse = 1;
      for (k = l = 0, len = warehouses.length; l < len; k = ++l) {
        warehouse = warehouses[k];
        for (i = m = 1, ref = sweepersPerWarehouse; 1 <= ref ? m <= ref : m >= ref; i = 1 <= ref ? ++m : --m) {
          ref1 = costDistance(warehouse.location, 1000, 10, 15), location = ref1[0], cost = ref1[1], distance = ref1[2];
          seller = {
            id: 'vend' + j,
            name: 'sweepSeller ' + j,
            location: location,
            kind: 'sweeper',
            type: 'Sweeper'
          };
          sweep_sellers.push(seller);
          all.push(seller);
          route = makeRoute(id++, seller, 'sweeps_to', warehouse, cost, distance);
          routes.push(route);
          j += 10;
        }
      }
      args.sweep_sellers = sweep_sellers;
      return callback(null, args);
    };
    buildSellers = function(args, callback) {
      var i, inventory, j, l, location, numSellers, ref, seller;
      all = args.all;
      numSellers = 3;
      sellers = [];
      j = 1000;
      for (i = l = 0, ref = 100 / numSellers; l <= 100; i = l += ref) {
        inventory = 0;
        if (i < 50) {
          location = math.floor(math.random(1, 27));
        } else if (i > 50) {
          location = math.floor(math.random(72, 98));
        } else {
          location = 53;
          inventory = 4;
        }
        seller = {
          id: 'sell' + j,
          name: 'seller' + j,
          location: location,
          kind: 'seller',
          inventory: inventory,
          type: 'Seller'
        };
        sellers.push(seller);
        all.push(seller);
        j += 100;
      }
      args.sellers = sellers;
      return callback(null, args);
    };
    buildEdgesNInventory = function(args, callback) {
      var cost, distance, l, len, len1, m, node, route, zip, zips;
      all = args.all;
      routes = args.routes;
      zips = args.zips;
      edges = [];
      console.log("warehouse edges");
      for (l = 0, len = all.length; l < len; l++) {
        node = all[l];
        for (m = 0, len1 = zips.length; m < len1; m++) {
          zip = zips[m];
          distance = math.floor(math.abs(node.location - zip.location));
          cost = distance;
          route = makeRoute(id++, node, 'leaf', zip, cost, distance);
          routes.push(route);
          if (!(node.inventory != null)) {
            node.inventory = math.floor(math.random(0, 2));
          }
        }
      }
      return callback(null, args);
    };
    buildZips = function(args, callback) {
      var distance, i, ix, l, location, m, makezip, numweights, numzips, ref, ref1, weight, weightfactor, weights, zip, zipnum, zips;
      zips = [];
      weights = [];
      all = args.all;
      ix = 0;
      numzips = 3;
      numweights = 3;
      makezip = function(zipnum, location, weight, distance) {
        return {
          id: zipnum + weight,
          kind: 'zip',
          type: 'Zip',
          zip: zipnum,
          name: '' + zipnum + weight,
          city: "city_" + i,
          state: String.fromCharCode(65 + i * 2) + String.fromCharCode(65 + i * 2 + 1),
          latitude: "" + location,
          longitude: "" + (location + distance),
          location: "" + location,
          timezone: "-" + (4 + math.floor(i / 2)),
          dst: "" + math.floor(i / 4),
          code: weight,
          lo: weight,
          hi: weight + 100
        };
      };
      console.log("weights and zips");
      for (weightfactor = l = 0, ref = numweights; 0 <= ref ? l < ref : l > ref; weightfactor = 0 <= ref ? ++l : --l) {
        weight = 100 * weightfactor;
        weights.push({
          weight: weight,
          zips: []
        });
        for (i = m = 0, ref1 = numzips; 0 <= ref1 ? m < ref1 : m > ref1; i = 0 <= ref1 ? ++m : --m) {
          distance = math.floor(100 / numzips) + 1;
          location = distance * i;
          zipnum = 20000 * i;
          zip = makezip(zipnum, location, weight, distance);
          zips.push(zip);
          weights[ix].zips.push(zip);
        }
        ix++;
      }
      args.zips = zips;
      args.weights = weights;
      return callback(null, args);
    };
    makeRoute = function(id, source, kind, destination, cost, distance) {
      return {
        id: id,
        source: source,
        kind: kind,
        destination: destination,
        estimate: {
          cost: cost,
          distance: distance
        },
        type: kind
      };
    };
    buildZipRelationships = function(args, callback) {
      var cost, distance, l, len, len1, len2, m, n, ref, ref1, route, weight, weightclass, weights, zip1, zip2;
      all = args.all;
      routes = args.routes;
      weights = args.weights;
      console.log("zip->zip(zip-weight)");
      for (l = 0, len = weights.length; l < len; l++) {
        weightclass = weights[l];
        weight = weightclass.weight;
        ref = weightclass.zips;
        for (m = 0, len1 = ref.length; m < len1; m++) {
          zip1 = ref[m];
          ref1 = weightclass.zips;
          for (n = 0, len2 = ref1.length; n < len2; n++) {
            zip2 = ref1[n];
            distance = math.floor(math.abs(zip1.location - zip2.location)) * weight / 500;
            cost = distance;
            route = {
              id: id++,
              source: zip1,
              kind: 'zip',
              destination: zip2,
              estimate: {
                cost: cost,
                distance: distance
              }
            };
            routes.push(route);
          }
        }
      }
      callback(null, args);
    };
    buildSKUS = function(args, callback) {
      var i, l, numSkus, ref, sku, skunum, skus;
      skus = [];
      numSkus = 3;
      all = args.all;
      console.log("SKUS");
      for (i = l = 1, ref = numSkus; 1 <= ref ? l <= ref : l >= ref; i = 1 <= ref ? ++l : --l) {
        skunum = i * 300000;
        sku = {
          id: skunum,
          kind: 'sku',
          sku: skunum,
          name: '' + skunum,
          type: 'Sku'
        };
        skus.push(sku);
      }
      args.skus = skus;
      return callback(null, args);
    };
    buildSKURelationships = function(args, callback) {
      var inventory, l, len, len1, m, node, route, sku, skus;
      skus = args.skus;
      all = args.all;
      routes = args.routes;
      console.log("SKU to node");
      for (l = 0, len = all.length; l < len; l++) {
        node = all[l];
        if (node.kind !== 'consumer') {
          for (m = 0, len1 = skus.length; m < len1; m++) {
            sku = skus[m];
            inventory = math.floor(math.random(0, 10));
            if (inventory > 0) {
              route = makeSkuRoute(id, sku, 'sku', node, inventory);
              routes.push(route);
            }
          }
        }
      }
      callback(null, args);
    };
    buildGraph = function(callback1) {
      return async.waterfall([
        function(callback2) {
          return buildResuppliers(callback2);
        }, function(args3, callback3) {
          return buildResupplierRoutes(args3, callback3);
        }, function(args4, callback4) {
          return buildWarehouses(args4, callback4);
        }, function(args5, callback5) {
          return buildSellerSweepersNRoutes(args5, callback5);
        }, function(args6, callback6) {
          return buildSellers(args6, callback6);
        }, function(args, callback) {
          return buildZips(args, callback);
        }, function(args, callback) {
          return buildZipRelationships(args, callback);
        }, function(args, callback) {
          return buildEdgesNInventory(args, callback);
        }, function(args, callback) {
          return buildSKUS(args, callback);
        }, function(args, callback) {
          return buildSKURelationships(args, callback);
        }, function(args10, callback10) {
          return persistGraph(args10, callback10);
        }
      ], function(error, result) {
        callback1(error, result);
      });
    };
    persistGraph = function(args, callback) {
      var l, len, len1, len2, m, n, node, nodeStr, nodeString, session, sku, skuStr, skuString, skus, tx, zip, zipStr, zipString, zips;
      all = args.all;
      superdcs = args.superdcs;
      warehouses = args.warehouses;
      routes = args.routes;
      edges = args.routes;
      skus = args.skus;
      zips = args.zips;
      session = driver.session();
      tx = session.beginTransaction();
      for (l = 0, len = skus.length; l < len; l++) {
        sku = skus[l];
        skuString = "CREATE (:Sku {id: " + sku.id + ", sku: '" + sku.sku + "', kind: '" + sku.kind + "', name: '" + sku.name + "')";
        skuStr = "CREATE (:Sku {id: {id}, sku: {sku}, kind: {kind}, name: {name} })";
        tx.run(skuStr, sku);
      }
      for (m = 0, len1 = zips.length; m < len1; m++) {
        zip = zips[m];
        zipString = "CREATE (:Zip {id: " + zip.id + ", zip: " + zip.zip + ", city: '" + zip.city + "', state: '" + zip.state + "' latitude: " + zip.latitude + ", longitude: " + zip.longitude + ", location: " + zip.location + ", timezone: " + zip.timezone + "}, dst: " + zip.dst + ", kind: '" + zip.kind + "', name: '" + zip.name + "')";
        console.log(zipString);
        zipStr = "CREATE (:Zip {id: {id}, zip: {zip}, city: {city}, state: {state}, latitude: {latitude}, longitude: {longitude}, location: {location}, timezone: {timezone}, dst: {dst}, kind: {kind}, name: {name}, lo: {lo}, hi: {hi}, code: {code} })";
        tx.run(zipStr, zip);
      }
      for (n = 0, len2 = all.length; n < len2; n++) {
        node = all[n];
        nodeString = "CREATE (:" + node.type + " {id: '" + node.id + "', name: '" + node.name + "', location: " + node.location + ", kind: '" + node.kind + "', inventory: " + node.inventory + "})";
        console.log(nodeString);
        nodeStr = "CREATE (:" + node.type + " {id: {id}, name: {name}, location: {location}, kind: {kind}, inventory: {inventory}})";
        tx.run(nodeStr, node);
      }
      return tx.commit().subscribe({
        onCompleted: function() {
          var edge, len3, match, matchStr, o, params, session2, tx2;
          session.close();
          session2 = driver.session();
          tx2 = session2.beginTransaction();
          for (o = 0, len3 = edges.length; o < len3; o++) {
            edge = edges[o];
            if (edge.kind === 'sku') {
              params = {
                sourcekind: edge.source.type,
                sourcename: edge.source.name,
                destinationkind: edge.destination.type,
                destinationname: edge.destination.name,
                kind: edge.kind,
                inventory: edge.inventory
              };
              matchStr = "MATCH (a:" + params.sourcekind + " {name: " + params.sourcename + "}), (b:" + params.destinationkind + " {name: " + params.destinationname + "}) CREATE (a)-[rel:" + params.kind.toUpperCase() + " {kind: {" + params.kind + "}, inventory: " + params.inventory + "}]->(b) RETURN rel";
              match = "MATCH (a:" + params.sourcekind + " {name:{sourcename}}), (b:" + params.destinationkind + " {name:{destinationname}}) CREATE (a)-[rel:" + params.kind.toUpperCase() + " {kind: {kind}, inventory: {inventory}}]->(b) RETURN rel";
            } else {
              params = {
                sourcekind: edge.source.type,
                sourcename: edge.source.name,
                destinationkind: edge.destination.type,
                destinationname: edge.destination.name,
                kind: edge.kind,
                cost: edge.estimate.distance
              };
              matchStr = "MATCH (a:" + params.sourcekind + " {name: " + params.sourcename + "}), (b:" + params.destinationkind + " {name: " + params.destinationname + "}) CREATE (a)-[rel:" + params.kind.toUpperCase() + " {kind: {" + params.kind + "}, cost: " + params.cost + "}]->(b) RETURN rel";
              match = "MATCH (a:" + params.sourcekind + " {name:{sourcename}}), (b:" + params.destinationkind + " {name:{destinationname}}) CREATE (a)-[rel:" + params.kind.toUpperCase() + " {kind: {kind}, cost: {cost}}]->(b) RETURN rel";
            }
            console.log(matchStr);
            tx2.run(match, params);
          }
          return tx2.commit().subscribe({
            onCompleted: function() {
              console.log("completed");
              session2.close();
              callback(null, args);
            },
            onError: function(error) {
              console.log(error);
              session2.close();
              callback(error, args);
            }
          });
        },
        onError: function(error) {
          console.log(error);
          session.close();
          callback(error, args);
        }
      });
    };
    return it('builds simple graph with warehouses, zipcodes', function(done) {
      return deleteGraph(function() {
        return buildGraph(function(error, result) {
          return done();
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=build_graph.js.map
