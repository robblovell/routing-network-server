// Generated by CoffeeScript 1.10.0
(function() {
  var Builder, Papa, async, fs, geodist, iImport, math, papaConfig,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  iImport = require('./../iImport');

  fs = require('fs');

  async = require('async');

  math = require('mathjs');

  geodist = require('geodist');

  fs = require('fs');

  Papa = require('babyparse');

  papaConfig = {
    delimiter: ",",
    newline: "",
    header: true,
    dynamicTyping: false,
    preview: 0,
    encoding: "UTF-8",
    worker: false,
    comments: false,
    step: void 0,
    download: false,
    skipEmptyLines: false,
    fastMode: false
  };

  Builder = (function(superClass) {
    extend(Builder, superClass);

    function Builder(config, repo1) {
      this.config = config;
      this.repo = repo1 != null ? repo1 : null;
      this.build = bind(this.build, this);
      this.buildWarehousesToSatellites = bind(this.buildWarehousesToSatellites, this);
      this.wireupSatellites = bind(this.wireupSatellites, this);
      this.buildResuppliersToWarehouses = bind(this.buildResuppliersToWarehouses, this);
      this.wireupResuppliers = bind(this.wireupResuppliers, this);
      this.buildSweepsToWarehouses = bind(this.buildSweepsToWarehouses, this);
      this.wireupSweeps = bind(this.wireupSweeps, this);
      this.cleanupAndCollateWarehouses = bind(this.cleanupAndCollateWarehouses, this);
      this.buildSkusToWarehouses = bind(this.buildSkusToWarehouses, this);
      this.wireupSkustoWarehouses = bind(this.wireupSkustoWarehouses, this);
      this.buildWarehousesToZips = bind(this.buildWarehousesToZips, this);
      this.wireupWarehousesToZips = bind(this.wireupWarehousesToZips, this);
      this.buildLtlToLtl = bind(this.buildLtlToLtl, this);
      this.traverseZips = bind(this.traverseZips, this);
      this.wireupLtlsToLtls = bind(this.wireupLtlsToLtls, this);
      this.buildZipsToLtls = bind(this.buildZipsToLtls, this);
    }

    Builder.prototype.setRepo = function(repo) {
      return this.repo = repo;
    };

    Builder.prototype.wireupZipsToLtls = function(aix, nodes, ltls, callback) {
      var i, id, len, ltl, obj, params, zip;
      zip = nodes[aix];
      this.repo.pipeline();
      if ((zip != null) && zip.zip3 !== '') {
        for (i = 0, len = ltls.length; i < len; i++) {
          ltl = ltls[i];
          if (zip.id === '') {
            continue;
          }
          id = zip.zip3 + "_" + ltl.ltlCode + "_" + ltl.weightLo + "_" + ltl.weightHi;
          params = {
            sourcekind: 'Zip',
            sourceid: '' + zip.id,
            destinationkind: 'Ltl',
            destinationid: '' + id,
            kind: 'ZIPLTL'
          };
          obj = {
            kind: 'ZIPLTL',
            cost: 0,
            id: zip.id + "_" + id
          };
          this.repo.setEdge(params, obj);
        }
      }
      return this.repo.exec((function(_this) {
        return function(error, result) {
          console.log("nodes: " + nodes.length + " ix: " + aix);
          if ((error != null)) {
            console.log("error:" + result);
            return callback(error, result);
          } else if (aix + 1 < nodes.length) {
            return _this.wireupZipsToLtls(aix + 1, nodes, ltls, callback);
          } else {
            console.log("Finished");
            return callback(error, result);
          }
        };
      })(this));
    };

    Builder.prototype.buildZipsToLtls = function(callback) {
      var filename;
      filename = './data/weights-codes.csv';
      this.repo.find({
        type: "Zip"
      }, (function(_this) {
        return function(error, zips) {
          var contentsCodes, ltls, result;
          contentsCodes = fs.readFileSync(filename, 'utf8');
          result = Papa.parse(contentsCodes, papaConfig);
          ltls = result.data;
          _this.wireupZipsToLtls(0, zips, ltls, callback);
        };
      })(this));
    };

    Builder.prototype.wireupLtlsToLtls = function(aix, bix, zips, ltls, callback) {
      var distance, i, id1, id2, len, ltl, obj, params, zip1, zip2;
      zip1 = zips[aix];
      zip2 = zips[bix];
      this.repo.pipeline();
      if (zip1.zip3 !== '' && zip2 !== '') {
        for (i = 0, len = ltls.length; i < len; i++) {
          ltl = ltls[i];
          distance = geodist({
            lat: parseInt(zip1.latitude),
            lon: parseInt(zip1.longitude)
          }, {
            lat: parseInt(zip2.latitude),
            lon: parseInt(zip2.longitude)
          });
          id1 = zip1.zip3 + "_" + ltl.ltlCode + "_" + ltl.weightLo + "_" + ltl.weightHi;
          id2 = zip2.zip3 + "_" + ltl.ltlCode + "_" + ltl.weightLo + "_" + ltl.weightHi;
          params = {
            sourcekind: 'Ltl',
            sourceid: '' + id1,
            destinationkind: 'Ltl',
            destinationid: '' + id2,
            kind: 'LTL',
            cost: distance + 50,
            linkid: id1 + '_' + id2
          };
          obj = {
            kind: 'LTL',
            cost: distance + 50,
            id: id1 + "_" + id2
          };
          this.repo.setEdge(params, obj);
        }
      }
      return this.repo.exec((function(_this) {
        return function(error, result) {
          if ((error != null)) {
            console.log("error:" + result);
            callback(error, result);
          } else if (bix + 1 < zips.length) {
            _this.wireupLtlsToLtls(aix, bix + 1, zips, ltls, callback);
          } else if (aix + 1 < zips.length) {
            console.log("zip: " + zips[aix].zip3);
            _this.traverseZips(aix + 1, 0, zips, ltls, callback);
          } else {
            callback(error, result);
          }
        };
      })(this));
    };

    Builder.prototype.traverseZips = function(aix, bix, zips, ltls, callback) {
      this.wireupLtlsToLtls(aix, bix, zips, ltls, callback);
    };

    Builder.prototype.buildLtlToLtl = function(callback) {
      var filename;
      filename = './data/weights-codes.csv';
      this.repo.find({
        type: "Zip"
      }, (function(_this) {
        return function(error, zips) {
          var contentsCodes, ltls, result;
          contentsCodes = fs.readFileSync(filename, 'utf8');
          result = Papa.parse(contentsCodes, papaConfig);
          ltls = result.data;
          _this.traverseZips(0, 0, zips, ltls, callback);
        };
      })(this));
    };

    Builder.prototype.wireupWarehousesToZips = function(zips, warehouses, callback) {
      var i, id1, id2, len, matches, obj, params, warehouse, warehousezip3, zip;
      this.repo.pipeline();
      for (i = 0, len = warehouses.length; i < len; i++) {
        warehouse = warehouses[i];
        id1 = warehouse.id;
        warehousezip3 = warehouse.PostalCode.substring(0, 3);
        matches = zips.filter(function(obj) {
          return obj.zip3 === warehousezip3;
        });
        if (matches.length < 1) {
          console.log("ERROR:: Warehouse missing postal code: " + warehousezip3 + "  code: " + warehouse.PostalCode);
          continue;
        } else if (matches.length > 1) {
          console.log("ERROR:: More than one zip found.");
        }
        zip = matches[0];
        id2 = zip.id;
        params = {
          sourcekind: 'Warehouse',
          sourceid: '' + id1,
          destinationkind: 'Zip',
          destinationid: '' + id2,
          kind: 'WAREHOUSEZIP',
          linkid: id1 + '_' + id2
        };
        obj = {
          kind: 'WAREHOUSEZIP',
          id: id1 + "_" + id2
        };
        this.repo.setEdge(params, obj);
      }
      console.log("finished");
      this.repo.exec((function(_this) {
        return function(error, result) {
          if ((error != null)) {
            console.log("error:" + result);
            callback(error, result);
          } else {
            callback(error, result);
          }
        };
      })(this));
    };

    Builder.prototype.buildWarehousesToZips = function(callback) {
      var filename;
      filename = './data/warehouses.csv';
      this.repo.find({
        type: "Zip"
      }, (function(_this) {
        return function(error, zips) {
          return _this.repo.find({
            type: "Warehouse"
          }, function(error, warehouses) {
            _this.wireupWarehousesToZips(zips, warehouses, callback);
          });
        };
      })(this));
    };

    Builder.prototype.wireupSkustoWarehouses = function(aix, skus, warehouses, callback) {
      var i, id1, id2, len, obj, params, sku, warehouse;
      this.repo.pipeline();
      sku = skus[aix];
      if (sku != null) {
        id1 = sku.id;
        for (i = 0, len = warehouses.length; i < len; i++) {
          warehouse = warehouses[i];
          id2 = warehouse.id;
          params = {
            sourcekind: 'Sku',
            sourceid: '' + id1,
            destinationkind: 'Warehouse',
            destinationid: '' + id2,
            kind: 'SKUWAREHOUSE',
            linkid: id1 + '_' + id2
          };
          obj = {
            kind: 'SKUWAREHOUSE',
            id: id1 + "_" + id2,
            inventory: math.floor(math.random(0, 100))
          };
          this.repo.setEdge(params, obj);
        }
      }
      this.repo.exec((function(_this) {
        return function(error, result) {
          if ((error != null)) {
            console.log("error:" + result);
            callback(error, result);
          } else if (aix < skus.length) {
            console.log("Sku: " + aix + "  " + JSON.stringify(sku));
            _this.wireupSkustoWarehouses(aix + 1, skus, warehouses, callback);
          } else {
            console.log("finished");
            callback(error, result);
          }
        };
      })(this));
    };

    Builder.prototype.buildSkusToWarehouses = function(callback) {
      this.repo.find({
        type: "Sku"
      }, (function(_this) {
        return function(error, skus) {
          return _this.repo.find({
            type: "Warehouse"
          }, function(error, warehouses) {
            _this.wireupSkustoWarehouses(0, skus, warehouses, callback);
          });
        };
      })(this));
    };

    Builder.prototype.cleanupAndCollateWarehouses = function(warehouses, zips) {
      var bdwps, flag, flags, i, j, k, l, len, len1, len2, len3, len4, len5, len6, m, matches, n, o, resuppliers, satellites, sellers, sweepers, warehouse, zip;
      flags = ['isSeller', 'isSweepable', 'IsBDWP', 'IsResupplier', 'IsCustomerPickup', 'IsSatellite'];
      for (i = 0, len = warehouses.length; i < len; i++) {
        warehouse = warehouses[i];
        for (j = 0, len1 = flags.length; j < len1; j++) {
          flag = flags[j];
          if (warehouse[flag] === -1 || warehouse[flag] === '-1' || warehouse[flag].toUpperCase() === 'TRUE' || warehouse[flag] === true || warehouse[flag] === 1 || warehouse[flag] === '1') {
            warehouse[flag] = true;
          } else {
            warehouse[flag] = false;
          }
        }
        zip = warehouse['PostalCode'].substring(0, 3);
        matches = zips.filter(function(obj) {
          return obj.zip3 === zip;
        });
        if (matches.length > 0) {
          zip = matches[0];
          warehouse.zip3 = zip.zip3;
          warehouse.lat = zip.latitude;
          warehouse.lon = zip.longitude;
          warehouse.haszip = true;
        } else {
          warehouse.haszip = false;
        }
      }
      bdwps = [];
      for (k = 0, len2 = warehouses.length; k < len2; k++) {
        warehouse = warehouses[k];
        if (warehouse.IsBDWP || warehouse.IsResupplier) {
          bdwps.push(warehouse);
        }
      }
      resuppliers = [];
      for (l = 0, len3 = warehouses.length; l < len3; l++) {
        warehouse = warehouses[l];
        if (warehouse.IsResupplier) {
          resuppliers.push(warehouse);
        }
      }
      sellers = [];
      for (m = 0, len4 = warehouses.length; m < len4; m++) {
        warehouse = warehouses[m];
        if (warehouse.isSeller) {
          sellers.push(warehouse);
        }
      }
      sweepers = [];
      for (n = 0, len5 = warehouses.length; n < len5; n++) {
        warehouse = warehouses[n];
        if (warehouse.isSweepable) {
          sweepers.push(warehouse);
        }
      }
      satellites = [];
      for (o = 0, len6 = warehouses.length; o < len6; o++) {
        warehouse = warehouses[o];
        if (warehouse.IsSatellite) {
          satellites.push(warehouse);
        }
      }
      return {
        bdwps: bdwps,
        resuppliers: resuppliers,
        sellers: sellers,
        sweepers: sweepers,
        satellites: satellites,
        warehouses: warehouses
      };
    };

    Builder.prototype.wireupSweeps = function(warehouses, callback) {
      var bdwp, closest, cost, distance, found, i, id1, id2, j, len, len1, obj, params, ref, ref1, sweeper;
      this.repo.pipeline();
      ref = warehouses.sweepers;
      for (i = 0, len = ref.length; i < len; i++) {
        sweeper = ref[i];
        id1 = sweeper.id;
        if (!sweeper.haszip) {
          continue;
        }
        found = null;
        closest = -1;
        ref1 = warehouses.bdwps;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          bdwp = ref1[j];
          if (!bdwp.haszip) {
            continue;
          }
          distance = geodist({
            lat: parseInt(bdwp.lat),
            lon: parseInt(bdwp.lon)
          }, {
            lat: parseInt(sweeper.lat),
            lon: parseInt(sweeper.lon)
          });
          if (distance < closest || closest === -1) {
            closest = distance;
            found = bdwp;
          }
        }
        if (found != null) {
          id2 = found.id;
          cost = distance;
          params = {
            sourcekind: 'Warehouse',
            sourceid: '' + id1,
            destinationkind: 'Warehouse',
            destinationid: '' + id2,
            kind: 'SWEEP',
            linkid: id1 + '_' + id2
          };
          obj = {
            kind: 'SWEEP',
            cost: cost,
            id: id1 + "_" + id2
          };
          this.repo.setEdge(params, obj);
        } else {
          console.log("No warehouses found close to this sweeper, uses postal codes or the code is not assigned.");
        }
      }
      this.repo.exec((function(_this) {
        return function(error, result) {
          if ((error != null)) {
            console.log("error:" + result);
            callback(error, result);
          } else {
            console.log("finished");
            callback(error, result);
          }
        };
      })(this));
    };

    Builder.prototype.buildSweepsToWarehouses = function(callback) {
      this.repo.find({
        type: "Zip"
      }, (function(_this) {
        return function(error, zips) {
          return _this.repo.find({
            type: "Warehouse"
          }, function(error, warehouses) {
            var collation;
            collation = _this.cleanupAndCollateWarehouses(warehouses, zips);
            _this.wireupSweeps(collation, callback);
          });
        };
      })(this));
      return;
      return callback(null, true);
    };

    Builder.prototype.wireupResuppliers = function(warehouses, callback) {
      var bdwp, cost, distance, i, id1, id2, j, len, len1, obj, params, ref, ref1, resupplier;
      this.repo.pipeline();
      ref = warehouses.resuppliers;
      for (i = 0, len = ref.length; i < len; i++) {
        resupplier = ref[i];
        id1 = resupplier.id;
        if (!resupplier.haszip) {
          continue;
        }
        ref1 = warehouses.bdwps;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          bdwp = ref1[j];
          if (bdwp.haszip) {
            distance = geodist({
              lat: parseInt(bdwp.lat),
              lon: parseInt(bdwp.lon)
            }, {
              lat: parseInt(resupplier.lat),
              lon: parseInt(resupplier.lon)
            });
          } else {
            distance = -1;
          }
          id2 = bdwp.id;
          cost = distance;
          params = {
            sourcekind: 'Warehouse',
            sourceid: '' + id1,
            destinationkind: 'Warehouse',
            destinationid: '' + id2,
            kind: 'RESUPPLIES',
            linkid: id1 + '_' + id2
          };
          obj = {
            kind: 'RESUPPLIES',
            cost: cost,
            id: id1 + "_" + id2
          };
          console.log("resupplier: " + JSON.stringify(params));
          this.repo.setEdge(params, obj);
        }
      }
      this.repo.exec((function(_this) {
        return function(error, result) {
          if ((error != null)) {
            console.log("error:" + result);
            callback(error, result);
          } else {
            console.log("finished");
            callback(error, result);
          }
        };
      })(this));
    };

    Builder.prototype.buildResuppliersToWarehouses = function(callback) {
      this.repo.find({
        type: "Zip"
      }, (function(_this) {
        return function(error, zips) {
          return _this.repo.find({
            type: "Warehouse"
          }, function(error, warehouses) {
            var collation;
            collation = _this.cleanupAndCollateWarehouses(warehouses, zips);
            _this.wireupResuppliers(collation, callback);
          });
        };
      })(this));
      return;
      return callback(null, true);
    };

    Builder.prototype.wireupSatellites = function(warehouses, callback) {
      var bdwp, closest, cost, distance, found, i, id1, id2, j, len, len1, obj, params, ref, ref1, satellite;
      this.repo.pipeline();
      ref = warehouses.bdwps;
      for (i = 0, len = ref.length; i < len; i++) {
        bdwp = ref[i];
        id1 = bdwp.id;
        if (!bdwp.haszip) {
          continue;
        }
        found = null;
        closest = -1;
        ref1 = warehouses.satellites;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          satellite = ref1[j];
          if (!satellite.haszip) {
            continue;
          }
          distance = geodist({
            lat: parseInt(bdwp.lat),
            lon: parseInt(bdwp.lon)
          }, {
            lat: parseInt(satellite.lat),
            lon: parseInt(satellite.lon)
          });
          if (distance < closest || closest === -1) {
            closest = distance;
            found = satellite;
          }
        }
        if ((found != null) && distance < 300) {
          id2 = found.id;
          cost = distance;
          params = {
            sourcekind: 'Warehouse',
            sourceid: '' + id1,
            destinationkind: 'Warehouse',
            destinationid: '' + id2,
            kind: 'REPOSITION',
            linkid: id1 + '_' + id2
          };
          obj = {
            kind: 'REPOSITION',
            cost: cost,
            id: id1 + "_" + id2
          };
          console.log("satellite: " + JSON.stringify(params));
          this.repo.setEdge(params, obj);
        } else {
          console.log("No satellite found close to this warehouse, uses postal codes or the code is not assigned.");
        }
      }
      this.repo.exec((function(_this) {
        return function(error, result) {
          if ((error != null)) {
            console.log("error:" + result);
            callback(error, result);
          } else {
            console.log("finished");
            callback(error, result);
          }
        };
      })(this));
    };

    Builder.prototype.buildWarehousesToSatellites = function(callback) {
      this.repo.find({
        type: "Zip"
      }, (function(_this) {
        return function(error, zips) {
          return _this.repo.find({
            type: "Warehouse"
          }, function(error, warehouses) {
            var collation;
            collation = _this.cleanupAndCollateWarehouses(warehouses, zips);
            _this.wireupSatellites(collation, callback);
          });
        };
      })(this));
      return;
      return callback(null, true);
    };

    Builder.prototype.build = function(callback) {
      async.parallel([
        (function(_this) {
          return function(callback) {
            return _this.buildZipsToLtls(callback);
          };
        })(this), (function(_this) {
          return function(callback) {
            return _this.buildLtlsToLtls(callback);
          };
        })(this), (function(_this) {
          return function(callback) {
            return _this.buildSweepsToWarehouses(callback);
          };
        })(this), (function(_this) {
          return function(callback) {
            return _this.buildResuppliersToWarehouses(callback);
          };
        })(this), (function(_this) {
          return function(callback) {
            return _this.buildWarehousesToWarehouses(callback);
          };
        })(this), (function(_this) {
          return function(callback) {
            return _this.buildWarehousesToZips(callback);
          };
        })(this), (function(_this) {
          return function(callback) {
            return _this.buildSkusToWarehouses(callback);
          };
        })(this)
      ], (function(_this) {
        return function(error, result) {
          return callback(error, result);
        };
      })(this));
    };

    return Builder;

  })(iImport);

  module.exports = Builder;

}).call(this);

//# sourceMappingURL=EdgeBuilder.js.map
