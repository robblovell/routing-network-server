// Generated by CoffeeScript 1.10.0
(function() {
  var async, iRepository, neo4j, request, uuid,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  async = require('async');

  request = require('superagent');

  iRepository = require('./iRepository');

  neo4j = require('neo4j-driver').v1;

  uuid = require('uuid');

  module.exports = iRepository = (function() {
    function iRepository(config) {
      this.config = config;
      this.exec = bind(this.exec, this);
      this.set = bind(this.set, this);
      this.buffer = null;
      if (this.config.url == null) {
        this.config.url = 'bolt://neo4j:macro7@localhost';
      }
      if (this.config.url.indexOf(':') > -1 && this.config.url.indexOf('@') > -1) {
        this.config.user = this.config.url.split("//")[1].split(":")[0];
        this.config.pass = this.config.url.split("//")[1].split("@")[0].split(":")[1];
        this.config.url = this.config.url.replace(this.config.user + ":" + this.config.pass + "@", "");
      }
      this.neo4j = neo4j.driver(this.config.url, neo4j.auth.basic(this.config.user, this.config.pass));
      return;
    }

    iRepository.prototype.find = function(example, callback) {
      var cypher;
      cypher = "Match (n:" + example.type + ") RETURN n";
      return this.run(cypher, {}, callback);
    };

    iRepository.prototype.run = function(cypher, data, callback) {
      var session;
      if (callback == null) {
        callback = null;
      }
      if ((this.buffer != null) || (callback == null)) {
        this.buffer.run(cypher, data);
      } else {
        session = this.neo4j.session();
        session.run(cypher, data).then((function(_this) {
          return function(result) {
            var i, len, record, ref, results;
            session.close();
            if (result && result.records[0] && result.records[0]._fields) {
              if (result.records.length === 1) {
                callback(null, JSON.stringify(result.records[0]._fields[0].properties));
              } else {
                results = [];
                ref = result.records;
                for (i = 0, len = ref.length; i < len; i++) {
                  record = ref[i];
                  results.push(record._fields[0].properties);
                }
                callback(null, results);
              }
            } else {
              callback(null, "{}");
            }
          };
        })(this))["catch"]((function(_this) {
          return function(error) {
            console.log("Error:" + error);
            session.close();
            callback(error, null);
          };
        })(this));
      }
    };

    iRepository.prototype.get = function(example, callback) {
      var cypher;
      if (example.id === "" || example.id === null) {
        callback(null, "{}");
        return;
      }
      cypher = "MATCH (n:" + example.type + ") WHERE n.id = {id} RETURN n";
      return this.run(cypher, example, callback);
    };

    iRepository.prototype.add = function(cypher, callback) {
      throw new Error('not implemented');
    };

    iRepository.prototype.set = function(id, obj, callback) {
      var data, makeUpsert, ref, session, upsert;
      makeUpsert = function(data) {
        var create, key, properties, update, upsertStatement, value;
        if (!(data.id != null)) {
          data.id = uuid.v4();
        }
        properties = ((function() {
          var results1;
          results1 = [];
          for (key in data) {
            value = data[key];
            results1.push("n." + key + " = {" + key + "}, ");
          }
          return results1;
        })()).reduce(function(t, s) {
          return t + s;
        });
        properties = properties.slice(0, -2);
        create = "n.created=timestamp(), " + properties;
        update = "n.updated=timestamp(), " + properties;
        upsertStatement = ("MERGE (n:" + data.type + " { id: {id} }) ON CREATE SET ") + create + " ON MATCH SET " + update;
        return [data, upsertStatement];
      };
      if (id) {
        obj.id = id;
      }
      if ((this.buffer != null) || (callback == null)) {
        ref = makeUpsert(obj), data = ref[0], upsert = ref[1];
        this.buffer.run(upsert, data);
      } else {
        session = this.neo4j.session();
        session.run(upsert, data).then((function(_this) {
          return function(result) {
            session.close();
            return callback(null, result);
          };
        })(this))["catch"]((function(_this) {
          return function(error) {
            session.close();
            return callback(error, null);
          };
        })(this));
      }
    };

    iRepository.prototype["delete"] = function(id) {};

    iRepository.prototype.pipeline = function() {
      this.session = this.neo4j.session();
      this.buffer = this.session.beginTransaction();
    };

    iRepository.prototype.exec = function(callback) {
      return this.buffer.commit().subscribe({
        onCompleted: (function(_this) {
          return function() {
            _this.session.close();
            _this.buffer = null;
            callback(null, "success");
          };
        })(this),
        onError: (function(_this) {
          return function(error) {
            _this.session.close();
            _this.buffer = null;
            callback(error, null);
          };
        })(this)
      });
    };

    return iRepository;

  })();

}).call(this);

//# sourceMappingURL=Neo4jRepository.js.map
